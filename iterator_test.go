package laziter

import "testing"

func TestNextValue(t *testing.T) {
	iter := New[int](false)
	defer iter.Close()
	testNextValue(t, iter, true)
}

func TestNext(t *testing.T) {
	iter := New[int](false)
	defer iter.Close()
	go sampleValuesGenerator(iter.GetValuesProvider(), 5)

	for i := 0; i < 5; i++ {
		ok := iter.Next()
		if !ok {
			t.Errorf("got no value, index=%d", i)
		}
	}
	ok := iter.Next()
	if ok {
		t.Error("got value, expected none")
	}
}

func TestGetCurrentValue(t *testing.T) {
	iter := New[int](false)
	defer iter.Close()
	go sampleValuesGenerator(iter.GetValuesProvider(), 5)

	_, ok := iter.GetCurrentValue()
	if ok {
		t.Error("got value, expected none")
	}
	for i := 0; i < 5; i++ {
		if !iter.Next() {
			t.Errorf("got no value, index=%d", i)
		}
		value, ok := iter.GetCurrentValue()
		if value != i {
			t.Errorf("got wrong value. got=%d, expected=%d", value, i)
		}
		if !ok {
			t.Errorf("got no value, index=%d", i)
		}
	}
}

func TestResetIteratorPosition(t *testing.T) {
	iter := New[int](true)
	defer iter.Close()
	testNextValue(t, iter, true)
	iter.ResetIteratorPosition()
	testNextValue(t, iter, false) // Execute test again but without new values generated by goroutine
}

func TestYieldAndWait(t *testing.T) {
	iter := New[int](false)
	go func() {
		ok := iter.Next()
		if !ok {
			t.Error("Next() failed")
		}
		iter.Close()
	}()

	vp := iter.GetValuesProvider()
	if !vp.Wait() {
		t.Error("Wait() failed")
	}
	vp.Yield(1)
	if vp.Wait() {
		t.Error("Wait() succeeded, expected fail")
	}
}

func testNextValue(t *testing.T, iter Iterator[int], withValuesGenerator bool) {
	if withValuesGenerator {
		go sampleValuesGenerator(iter.GetValuesProvider(), 5)
	}

	for i := 0; i < 5; i++ {
		value, ok := iter.NextValue()
		if value != i {
			t.Errorf("got wrong value. got=%d, expected=%d", value, i)
		}
		if !ok {
			t.Errorf("got no value, index=%d", i)
		}
	}
	_, ok := iter.NextValue()
	if ok {
		t.Error("got value, expected none")
	}
}

func sampleValuesGenerator(vp ValuesProvider[int], valuesCount int) {
	defer vp.Close()
	for i := 0; i < valuesCount; i++ {
		if !vp.Wait() {
			break
		}
		vp.Yield(i)
	}
}
